# Image Enhancement and Tumor Detection using PyMp

Image enhancement is very popular domain especially in the medical sphere. Most of the enhancement is done with classification as an end goal. For example, detecting if a tumor is malignant or benign based on a scan. There are numerous existing systems which does image enhancement to increase the probability for tumor detection or any other medical applications but there are very less solutions that can be deployed in real time basis due to the time constraints. Medical Image analysis can be considered as a critical application and desire to make the computations as real time as possible always exists. The drawbacks of most of the existing system is that it is computationally very expensive in terms of time when applied across large data sets. It is this drawback that we are trying to reduce
by parallelising the computations. The current image enhancement pipeline we have chosen is an application of simple image enhancement techniques such as fundamental Laplacian Sharpening, Gaussian Smoothing, Sobel, Otsu’s Algorithm and Power Law transformation. Hence the goal of proposed system is to reduce the execution time by parallelising at every sage which leads to an overall cascaded performance boost.

# Methodology

The initial image is an MRI scan of a certain body part used to detect tumor. The objective is to enhance this image by sharpening it and by bringing out more of the skeletal detail. The narrow dynamic range of the gray levels and high noise content make this image difficult to enhance. The strategy we will follow is to utilize the Laplacian to highlight fine detail, and the gradient to enhance prominent edges. A smoothed version of the gradient image will be used to mask the
Laplacian image. Finally, the dynamic range of the gray levels can be increased by using a gray-level transformation. Laplacian is applied to the original image followed by adding the original image to the image on which Laplacian filter has been applied to obtain a sharpened image, which is an implementation of the equation g(x, y) = f(x, y) + ∇^2 f(x, y) (we used a mask with a positive center coefficient). A noisy sharpened image is obtained. This image can be improved by using a mask formed from a smoothed version of the gradient of the original image. The motivation behind this is straightforward and is based on the properties
of first- and second-order derivatives. The Laplacian, being a second-order derivative operator, has the definite advantage that it is superior in enhancing fine detail. However, this causes it to produce noisier results than the gradient. This noise is most objectionable in smooth areas, where it tends to be more visible. The gradient has a stronger response in areas of significant gray-level transitions (gray-level ramps and steps) than does the Laplacian. The response of the gradient to noise and fine detail is lower than the Laplacian's and can be lowered further by smoothing the gradient with an averaging filter. The idea, then, is to smooth the gradient and multiply it by the Laplacian image. In this context, we may view the smoothed gradient as a mask image. The product will preserve details in the strong areas while reducing noise in the relatively flat areas. This process can be viewed roughly as combining the best features of the Laplacian and the gradient. The result is added to the original to obtain a final sharpened image, and could even be used in boost filtering. The next step is to show the Sobel gradient of the original image, computed using ∇ f=|Gx| + |Gy|. Edges are much more dominant in this image than in the Laplacian image. The smoothed gradient image is obtained by using an averaging filter of size 5 X 5. The gradient of an image with significant edge content has values that are higher in general than in a Laplacian image.

The same steps are carried out in our second algorithm except that instead of Sobel edge detection we use Otsu Binarization.

In order to carry out the above mentioned processes we have made use of a Python package called PyMP. This package brings OpenMP-like functionality to Python. It takes the good qualities of OpenMP such as minimal code changes and high efficiency and combines them with the Python Zen of code clarity and ease-of-use.

# Speedup

The speedup achieved for both otsu and sobel during parallel execution nearly 1.5 
